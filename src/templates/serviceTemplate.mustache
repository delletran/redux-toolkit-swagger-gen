/* eslint-disable */
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import { transformErrorResponse} from '../../redux/response';
import { toQueryString } from '../../redux/query';
import { TAGS } from '../../constants/tags';
import { RootState } from '../../redux/store';
import { API_CONFIG } from '../../redux/config/api';
// import { IFilters } from '../../redux/types';

{{#uniqueImports}}
{{#modelName}}
import { {{interface}} } from '../../models/{{modelName}}';
{{/modelName}}
{{/uniqueImports}}
{{#uniqueParamImports}}
{{#modelName}}
import { {{interface}} } from 'src/api/params/{{modelName}}';
{{/modelName}}
{{/uniqueParamImports}}


export const {{sliceName}} = createApi({
  reducerPath: {{{slicePath}}},
  baseQuery: fetchBaseQuery({
    baseUrl: API_CONFIG.BASE_URL,
    prepareHeaders: (headers, { getState }) => {
      const token = (getState() as RootState).auth?.token;
      if (token) {
        headers.set('Authorization', `Bearer ${token}`);
      }
      return headers;
    },
  }),
  tagTypes: Object.values(TAGS),
  endpoints: (builder) => ({ {{#endpoints}}
    {{name}}: builder.{{method}}<{{interface}}{{#isResponseArray}}[]{{/isResponseArray}}, {{#paramInterfaceName}}{{paramInterfaceName}}{{/paramInterfaceName}}{{^paramInterfaceName}}{{#requestBodyType}}{{requestBodyType}}{{#isRequestBodyArray}}[]{{/isRequestBodyArray}}{{/requestBodyType}}{{^requestBodyType}}{{{types}}}{{/requestBodyType}}{{/paramInterfaceName}}>({
      {{^isMutation}}{{#isListEndpoint}}
      query: ({{#hasPathParams}}{ {{pathParamsList}}, ...params }{{/hasPathParams}}{{^hasPathParams}}{{#params}}{{params}}{{/params}}{{^params}}_{{/params}}{{/hasPathParams}}) => {        
        let url = `{{{path}}}`;
        {{#hasPathParams}}
        const qs = toQueryString(params as Record<string, any>)
        {{/hasPathParams}}
        {{^hasPathParams}}
        {{#params}}
        const qs = toQueryString({{params}} as Record<string, any>)
        {{/params}}
        {{/hasPathParams}}
        {{#params}}
        return `${url}?${qs}`
        {{/params}}
        {{^params}}
        return url
        {{/params}}
      },
      transformErrorResponse: transformErrorResponse,
      providesTags: [TAGS.{{tag}}],
    }),
    {{/isListEndpoint}}
    {{^isListEndpoint}}
      query: ({{#hasPathParams}}{ {{pathParamsList}} }{{/hasPathParams}}{{^hasPathParams}}{{#params}}{{params}}{{/params}}{{^params}}_{{/params}}{{/hasPathParams}}) => {
        return `{{{path}}}`;
      },
      transformErrorResponse: transformErrorResponse,
      providesTags: [TAGS.{{tag}}],
    }),
    {{/isListEndpoint}}{{/isMutation}}{{#isMutation}}
      query: ({{#useBodyDestructuring}}{{#hasPathParams}}{ {{pathParamsList}}{{#bodyParam}}{{/bodyParam}}{{^bodyParam}}, ...body{{/bodyParam}} }{{/hasPathParams}}{{^hasPathParams}}body{{/hasPathParams}}{{/useBodyDestructuring}}{{^useBodyDestructuring}}{{#params}}{{params}}{{/params}}{{^params}}body{{/params}}{{/useBodyDestructuring}}) => {
        let url = `{{{path}}}`;
        return {
          url,
          method: '{{httpMethod}}',{{#useBodyDestructuring}}{{#requestBodyType}}{{#bodyParam}}
          body: { {{bodyParam}} },{{/bodyParam}}{{^bodyParam}}
          body,{{/bodyParam}}{{/requestBodyType}}{{/useBodyDestructuring}}{{^useBodyDestructuring}}{{#bodyParam}}
          body: {{bodyParam}},{{/bodyParam}}{{/useBodyDestructuring}}
          headers: {
            'Content-Type': '{{{contentType}}}',
          },
        };
      },
      transformErrorResponse: transformErrorResponse,
      invalidatesTags: [TAGS.{{tag}}],
    }),
    {{/isMutation}}
  {{/endpoints}}
  }),
});

export const {
  {{#endpoints}}{{#isQuery}}
  use{{exportName}}Query,{{/isQuery}}{{#isQuery}}
  useLazy{{exportName}}Query,{{/isQuery}}{{#isMutation}}
  use{{exportName}}Mutation,{{/isMutation}}
  {{/endpoints}}
} = {{sliceName}};
