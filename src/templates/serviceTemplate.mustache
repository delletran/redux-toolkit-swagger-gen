/* eslint-disable */
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
{{#useAtAlias}}
import { transformErrorResponse} from '@/api/redux/response';
import { toQueryString } from '@/api/redux/query';
import { TAGS } from '@/api/constants/tags';
import { RootState } from '@/api/redux/store';
import { API_CONFIG, getApiUrl } from '@/api/redux/config/api';
{{/useAtAlias}}
{{^useAtAlias}}
import { transformErrorResponse} from '../../redux/response';
import { toQueryString } from '../../redux/query';
import { TAGS } from '../../constants/tags';
import { RootState } from '../../redux/store';
import { API_CONFIG, getApiUrl } from '../../redux/config/api';
{{/useAtAlias}}
// import { IFilters } from '../../redux/types';

{{#uniqueImports}}
import { {{interface}} } from '{{{importPath}}}';
{{/uniqueImports}}
{{#uniqueParamImports}}
{{#modelName}}
{{#useAtAlias}}
import { {{interface}} } from '@/api/params/{{modelName}}';
{{/useAtAlias}}
{{^useAtAlias}}
import { {{interface}} } from '../../params/{{modelName}}';
{{/useAtAlias}}
{{/modelName}}
{{/uniqueParamImports}}


export const {{sliceName}} = createApi({
  reducerPath: {{{slicePath}}},
  baseQuery: fetchBaseQuery({
    baseUrl: API_CONFIG.BASE_URL,
    prepareHeaders: (headers, { getState }) => {
      const access_token = (getState() as RootState).auth?.access_token;
      if (access_token) {
        headers.set('Authorization', `Bearer ${access_token}`);
      }
      return headers;
    },
  }),
  tagTypes: Object.values(TAGS),
  endpoints: (builder) => ({ {{#endpoints}}
    /**{{#summary}}
     * {{summary}}{{/summary}}{{#description}}
     * {{description}}{{/description}}
     */
    {{name}}: builder.{{method}}<{{interface}}{{#isResponseArray}}[]{{/isResponseArray}}, {{#paramInterfaceName}}{{paramInterfaceName}}{{/paramInterfaceName}}{{^paramInterfaceName}}{{#requestBodyType}}{{requestBodyType}}{{#isRequestBodyArray}}[]{{/isRequestBodyArray}}{{/requestBodyType}}{{^requestBodyType}}{{{types}}}{{/requestBodyType}}{{/paramInterfaceName}}>({
      {{^isMutation}}{{#isListEndpoint}}
      query: ({{#hasPathParams}}{ {{pathParamsList}}, ...params }{{/hasPathParams}}{{^hasPathParams}}{{#params}}{{params}}{{/params}}{{^params}}_{{/params}}{{/hasPathParams}}) => {        
        let url = `{{{path}}}`;
        {{#hasPathParams}}
        const qs = toQueryString(params as Record<string, any>)
        {{/hasPathParams}}
        {{^hasPathParams}}
        {{#params}}
        const qs = toQueryString({{params}} as Record<string, any>)
        {{/params}}
        {{/hasPathParams}}
        {{#params}}
        return `${url}?${qs}`
        {{/params}}
        {{^params}}
        return url
        {{/params}}
      },
      transformErrorResponse: transformErrorResponse,
      providesTags: (result) => 
        result?.{{#paginatedArrayField}}{{paginatedArrayField}}{{/paginatedArrayField}}{{^paginatedArrayField}}results{{/paginatedArrayField}}
          ? [
              ...result.{{#paginatedArrayField}}{{paginatedArrayField}}{{/paginatedArrayField}}{{^paginatedArrayField}}results{{/paginatedArrayField}}.map(({ id }: any) => ({ type: TAGS.{{tag}}, id })),
              { type: TAGS.{{tag}}, id: 'LIST' },
            ]
          : [{ type: TAGS.{{tag}}, id: 'LIST' }],
    }),
    {{/isListEndpoint}}
    {{^isListEndpoint}}
      query: ({{#hasPathParams}}{ {{pathParamsList}}{{#params}}, ...params{{/params}} }{{/hasPathParams}}{{^hasPathParams}}{{#params}}{{params}}{{/params}}{{^params}}_{{/params}}{{/hasPathParams}}) => {
        let url = `{{{path}}}`;
        {{#params}}
        {{#hasPathParams}}
        const qs = toQueryString(params as Record<string, any>)
        {{/hasPathParams}}
        {{^hasPathParams}}
        const qs = toQueryString({{params}} as Record<string, any>)
        {{/hasPathParams}}
        return `${url}?${qs}`;
        {{/params}}
        {{^params}}
        return url;
        {{/params}}
      },
      transformErrorResponse: transformErrorResponse,
      providesTags: {{#hasPathParams}}(result, error, { {{pathParamsList}} }) => [{ type: TAGS.{{tag}}, id: {{pathParamsList}} }]{{/hasPathParams}}{{^hasPathParams}}[TAGS.{{tag}}]{{/hasPathParams}},
    }),
    {{/isListEndpoint}}{{/isMutation}}{{#isMutation}}
      query: ({{#paramInterfaceName}}{{#requestBodyType}}{ {{#allNonBodyParams}}{{allNonBodyParams}}, {{/allNonBodyParams}}body{{#hasQueryParamsForMutation}}, ...params{{/hasQueryParamsForMutation}} }{{/requestBodyType}}{{^requestBodyType}}{{#hasPathParams}}{ {{pathParamsList}}{{#hasQueryParamsForMutation}}, ...params{{/hasQueryParamsForMutation}} }{{/hasPathParams}}{{^hasPathParams}}params{{/hasPathParams}}{{/requestBodyType}}{{/paramInterfaceName}}{{^paramInterfaceName}}body{{/paramInterfaceName}}) => {
        let url = `{{{path}}}`;
        return {
          url,
          method: '{{httpMethod}}',{{#requestBodyType}}
          body,{{/requestBodyType}}
          headers: {
            'Content-Type': '{{{contentType}}}',
          },{{#hasQueryParamsForMutation}}
          params: params,{{/hasQueryParamsForMutation}}
        };
      },
      transformErrorResponse: transformErrorResponse,
      invalidatesTags: {{#hasPathParams}}(result, error, { {{pathParamsList}} }) => [{ type: TAGS.{{tag}}, id: {{pathParamsList}} }, { type: TAGS.{{tag}}, id: 'LIST' }]{{/hasPathParams}}{{^hasPathParams}}[{ type: TAGS.{{tag}}, id: 'LIST' }]{{/hasPathParams}},
    }),
    {{/isMutation}}
  {{/endpoints}}
  }),
});

export const {
  {{#endpoints}}{{#isQuery}}
  use{{exportName}}Query,{{/isQuery}}{{#isQuery}}
  useLazy{{exportName}}Query,{{/isQuery}}{{#isMutation}}
  use{{exportName}}Mutation,{{/isMutation}}
  {{/endpoints}}
} = {{sliceName}};
