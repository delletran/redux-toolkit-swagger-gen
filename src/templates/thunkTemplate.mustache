import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
// import type { PayloadAction } from '@reduxjs/toolkit';
// import { IFilters } from '../../redux/types';
{{#useAtAlias}}
import { toQueryString } from '@/api/redux/query';
import { getApiUrl } from '@/api/redux/config/api';
{{/useAtAlias}}
{{^useAtAlias}}
import { toQueryString } from '../../redux/query';
import { getApiUrl } from '../../redux/config/api';
{{/useAtAlias}}

{{#uniqueImports}}
{{#modelName}}
{{#useAtAlias}}
import { {{interface}} } from '@/api/models/{{modelName}}';
{{/useAtAlias}}
{{^useAtAlias}}
import { {{interface}} } from '../../models/{{modelName}}';
{{/useAtAlias}}
{{/modelName}}
{{/uniqueImports}}
{{#uniqueParamImports}}
{{#useAtAlias}}
import { {{paramInterface}} } from '@/api/params/{{paramPath}}.params';
{{/useAtAlias}}
{{^useAtAlias}}
import { {{paramInterface}} } from '../../params/{{paramPath}}.params';
{{/useAtAlias}}
{{/uniqueParamImports}}

interface {{sliceName}}State {
  entities: Record<string, any>[];
  loading: 'idle' | 'pending' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: {{sliceName}}State = {
  entities: [],
  loading: 'idle',
  error: null,
};

{{#endpoints}}
export const {{operationId}} = createAsyncThunk(
  '{{slicePath}}/{{operationId}}',
  async ({{#paramInterface}}params: {{paramInterface}}{{/paramInterface}}{{^paramInterface}}{{^params}}_{{/params}}{{#params}}{{params}}: {{types}}{{/params}}{{/paramInterface}}, { rejectWithValue }) => {
    try {
      {{#paramInterface}}
      const { {{paramsForDestructuring}}{{#hasRequestBody}}, body{{/hasRequestBody}} } = params;
      {{/paramInterface}}
      let endpoint = `{{{url}}}`;
      {{#queryParamsForObject}}
      const qs = toQueryString({{queryParamsForObject}});
      if (qs) endpoint += `?${qs}`;
      {{/queryParamsForObject}}
      const url = getApiUrl(endpoint);
      
      const response = await fetch(url, {
        method: '{{method}}',
        headers: {
          'Content-Type': 'application/json',
        },{{#hasRequestBody}}
        body: JSON.stringify(body),{{/hasRequestBody}}
      });

      if (!response.ok) {
        throw new Error('Network response was not ok');
      }

      return await response.json();
    } catch (error: any) {
      return rejectWithValue(error.message);
    }
  }
);
{{/endpoints}}

export const {{sliceName}}Slice = createSlice({
  name: '{{{slicePath}}}',
  initialState,
  reducers: {
    clearErrors: (state) => {
      state.error = null;
    },
    resetState: (state) => {
      state.entities = [];
      state.loading = 'idle';
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    {{#endpoints}}
    /** {{operationId}} **/
    builder
      .addCase({{operationId}}.pending, (state) => {
        state.loading = 'pending';
      })
      .addCase({{operationId}}.fulfilled, (state, action) => {
        state.loading = 'succeeded';
        {{#isListEndpoint}}
        state.entities = action.payload.results || [];
        {{/isListEndpoint}}
        {{^isListEndpoint}}
        if (Array.isArray(action.payload)) {
          state.entities = action.payload;
        } else {
          state.entities = [action.payload]  as Record<string, any>[];
        }
        {{/isListEndpoint}}
      })
      .addCase({{operationId}}.rejected, (state, action) => {
        state.loading = 'failed';
        state.error = action.payload as string;
      });
    {{/endpoints}}
  },
});

export const { clearErrors, resetState } = {{sliceName}}Slice.actions;
export default {{sliceName}}Slice.reducer;
