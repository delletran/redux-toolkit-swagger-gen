import Mustache from 'mustache';

import { EndpointFactory } from '../utils/end-points';
import { toCamelCase } from '../utils/formater';
import { loadTemplate } from '../utils/template-loader';

const serviceTemplate = loadTemplate('serviceTemplate.mustache');

export const apiServiceGenerator = (path: string, methods: Record<string, ReduxApiEndpointType>): string => {
  const endpoints = EndpointFactory.getEndpoints('service', path, methods);
  const uniqueImports = Array.from(
    new Map(
      endpoints.map(ep => [`${ep.interface}|${ep.modelName}`, { interface: ep.interface, modelName: ep.modelName }])
    ).values()
  );
  
  // Patch endpoint types for mutation: use request body type if available
  endpoints.forEach(ep => {
    if (ep.isMutation) {
      // Use route_key to ensure we get the correct method object from the methods map
      // The key may contain the HTTP method if the generateServices function was updated
      const methodKey = Object.keys(methods).find(k => k.includes(ep.path));
      const methodObj = methodKey ? methods[methodKey]?.methodObj : null;
      
      // Determine content type from OpenAPI spec
      if (methodObj?.requestBody?.content) {
        const contentTypes = Object.keys(methodObj.requestBody.content);
        if (contentTypes.includes('application/x-www-form-urlencoded')) {
          ep.contentType = 'application/x-www-form-urlencoded';
        } else if (contentTypes.includes('application/json')) {
          ep.contentType = 'application/json';
        } else if (contentTypes.length > 0) {
          // Use the first available content type if none of the above match
          ep.contentType = contentTypes[0];
        } else {
          // Default to application/json if no content types specified
          ep.contentType = 'application/json';
        }
      } else {
        // Default content type based on endpoint path for backward compatibility
        ep.contentType = ep.path.includes('/token') ? 
          'application/x-www-form-urlencoded' : 
          'application/json';
      }
      
      // Set correct request body type
      if (ep.requestBodyModelName) {
        ep.requestBodyType = `I${ep.requestBodyModelName}Serializer`;
      } else if (ep.modelName) {
        ep.requestBodyType = `I${ep.modelName}Serializer`;
      }
      
      console.log(`Mutation endpoint ${ep.path}: using content type ${ep.contentType} and request body type ${ep.requestBodyType || 'none'}`);
    }
  });
  
  // Add param imports for request body types
  const uniqueParamImports = Array.from(
    new Map(
      endpoints
        .filter(ep => ep.isMutation && ep.requestBodyModelName)
        .map(ep => {
          return [`${ep.requestBodyModelName}|${ep.requestBodyType}`, { 
            interface: ep.requestBodyType, 
            modelName: ep.requestBodyModelName
          }];
        })
    ).values()
  );

  const modelData = {
    sliceName: toCamelCase(path),
    slicePath: `"${path}-api"`,
    uniqueImports,
    uniqueParamImports,
    endpoints,
  };

  return Mustache.render(serviceTemplate, modelData);
};
